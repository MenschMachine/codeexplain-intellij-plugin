name: Release Plugin

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      prerelease:
        description: 'Is this a pre-release?'
        type: boolean
        default: false

# Permissions needed for creating releases
permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: gradle

      - name: Setup Gradle
        uses: gradle/gradle-build-action@v2
        with:
          gradle-version: 8.5

      - name: Make gradlew executable
        run: chmod +x ./gradlew

      - name: Setup version management scripts
        run: |
          # Create the get-current-version script
          cat > get-current-version.sh << 'EOL'
#!/bin/bash
# Script to extract the current version from build.gradle
# Usage: ./get-current-version.sh [path/to/build.gradle]

# Set the build.gradle path (default to build.gradle in current directory)
BUILD_GRADLE=${1:-"build.gradle"}

if [ ! -f "$BUILD_GRADLE" ]; then
  echo "Error: $BUILD_GRADLE not found" >&2
  exit 1
fi

# Debug: Print the build.gradle content
echo "Analyzing $BUILD_GRADLE..." >&2

# Try to find the group line and the version on the next line
GROUP_LINE_NUM=$(grep -n "group 'xyz.codeexplain'" "$BUILD_GRADLE" | cut -d ':' -f1)

if [ -n "$GROUP_LINE_NUM" ]; then
  # Get the next line after the group line
  NEXT_LINE_NUM=$((GROUP_LINE_NUM + 1))
  VERSION_LINE=$(sed -n "${NEXT_LINE_NUM}p" "$BUILD_GRADLE")
  echo "Found version line: $VERSION_LINE" >&2
  
  # Extract version from the line, handling potential whitespace
  if [[ $VERSION_LINE =~ [[:space:]]*version[[:space:]]*\'([^\']*)\'|[[:space:]]*version[[:space:]]*\"([^\"]*)\" ]]; then
    if [ -n "${BASH_REMATCH[1]}" ]; then
      CURRENT_VERSION="${BASH_REMATCH[1]}"
    else
      CURRENT_VERSION="${BASH_REMATCH[2]}"
    fi
  else
    # Try a simpler approach with grep
    if [[ $VERSION_LINE =~ version ]]; then
      if [[ $VERSION_LINE =~ "'" ]]; then
        CURRENT_VERSION=$(echo "$VERSION_LINE" | grep -oP "version\s*'\K[^']+")
      else
        CURRENT_VERSION=$(echo "$VERSION_LINE" | grep -oP 'version\s*"\K[^"]+')  
      fi
    fi
    
    if [ -z "$CURRENT_VERSION" ]; then
      echo "Could not parse version from line: $VERSION_LINE" >&2
      # Fall back to searching the whole file
      echo "Falling back to whole file search..." >&2
    fi
  fi
fi

# If we couldn't find the version after the group line, try searching the whole file
if [ -z "$CURRENT_VERSION" ]; then
  echo "Searching entire file for version..." >&2
  if grep -q "version '[^']*'" "$BUILD_GRADLE"; then
    CURRENT_VERSION=$(grep -oP "version '\K[^']+" "$BUILD_GRADLE")
  elif grep -q 'version "[^"]*"' "$BUILD_GRADLE"; then
    CURRENT_VERSION=$(grep -oP 'version "\K[^"]+' "$BUILD_GRADLE")
  else
    echo "Could not find version in $BUILD_GRADLE, defaulting to 0.0.1" >&2
    CURRENT_VERSION="0.0.1"
  fi
fi

echo "Current version: $CURRENT_VERSION" >&2

# Output only the version number (for use in scripts)
echo "$CURRENT_VERSION"
EOL

          # Create the bump-version script
          cat > bump-version.sh << 'EOL'
#!/bin/bash
# Script to bump the version number in build.gradle
# Usage: ./bump-version.sh [path/to/build.gradle] [major|minor|patch] [--snapshot]

# Set the build.gradle path (default to build.gradle in current directory)
BUILD_GRADLE=${1:-"build.gradle"}
# Set the version part to bump (default to patch)
BUMP_TYPE=${2:-"patch"}
# Check if snapshot flag is set
SNAPSHOT=false
if [[ "$3" == "--snapshot" ]]; then
  SNAPSHOT=true
fi

if [ ! -f "$BUILD_GRADLE" ]; then
  echo "Error: $BUILD_GRADLE not found" >&2
  exit 1
fi

# Get the current version
CURRENT_VERSION=$(./get-current-version.sh "$BUILD_GRADLE")
echo "Current version: $CURRENT_VERSION"

# Remove -SNAPSHOT suffix if present
BASE_VERSION=${CURRENT_VERSION%-SNAPSHOT}
echo "Base version: $BASE_VERSION"

# Check if version follows semver pattern
if [[ ! $BASE_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
  echo "Warning: Current version doesn't follow semantic versioning pattern (X.Y.Z). Using 0.0.1 as base."
  BASE_VERSION="0.0.1"
fi

# Split version into components
IFS='.' read -r -a VERSION_PARTS <<< "$BASE_VERSION"
MAJOR=${VERSION_PARTS[0]:-0}
MINOR=${VERSION_PARTS[1]:-0}
PATCH=${VERSION_PARTS[2]:-0}

echo "Parsed version: Major=$MAJOR, Minor=$MINOR, Patch=$PATCH"

# Bump the version according to the specified type
case "$BUMP_TYPE" in
  major)
    NEW_MAJOR=$((MAJOR + 1))
    NEW_VERSION="$NEW_MAJOR.0.0"
    ;;
  minor)
    NEW_MINOR=$((MINOR + 1))
    NEW_VERSION="$MAJOR.$NEW_MINOR.0"
    ;;
  patch|*)
    NEW_PATCH=$((PATCH + 1))
    NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
    ;;
esac

# Add -SNAPSHOT suffix if requested
if [ "$SNAPSHOT" = true ]; then
  NEW_VERSION="${NEW_VERSION}-SNAPSHOT"
fi

echo "New version: $NEW_VERSION"

# Update the version in build.gradle
# First, try to find the group line and update the version on the next line
GROUP_LINE_NUM=$(grep -n "group 'xyz.codeexplain'" "$BUILD_GRADLE" | cut -d ':' -f1)

if [ -n "$GROUP_LINE_NUM" ]; then
  echo "Found 'group 'xyz.codeexplain'' at line $GROUP_LINE_NUM"
  # Get the next line after the group line
  NEXT_LINE_NUM=$((GROUP_LINE_NUM + 1))
  VERSION_LINE=$(sed -n "${NEXT_LINE_NUM}p" "$BUILD_GRADLE")
  echo "Version line: $VERSION_LINE"
  
  # Check if the next line contains a version declaration
  if [[ $VERSION_LINE =~ version ]]; then
    echo "Updating version at line $NEXT_LINE_NUM"
    
    # Create a temporary file
    TEMP_FILE=$(mktemp)
    
    # Process the file line by line
    LINE_NUM=1
    while IFS= read -r LINE || [ -n "$LINE" ]; do
      if [ $LINE_NUM -eq $NEXT_LINE_NUM ]; then
        # Replace the version line
        if [[ $LINE =~ "'" ]]; then
          # Version is defined with single quotes
          NEW_LINE=$(echo "$LINE" | sed "s/version '[^']*'/version '$NEW_VERSION'/")
        else
          # Version is defined with double quotes
          NEW_LINE=$(echo "$LINE" | sed "s/version \"[^\"]*\"/version \"$NEW_VERSION\"/")
        fi
        echo "$NEW_LINE" >> "$TEMP_FILE"
      else
        # Keep the line unchanged
        echo "$LINE" >> "$TEMP_FILE"
      fi
      LINE_NUM=$((LINE_NUM + 1))
    done < "$BUILD_GRADLE"
    
    # Ensure the file ends with a newline
    if [ "$(tail -c 1 "$TEMP_FILE" | wc -l)" -eq 0 ]; then
      echo "" >> "$TEMP_FILE"
    fi
    
    # Replace the original file with the modified one
    mv "$TEMP_FILE" "$BUILD_GRADLE"
    
    echo "Successfully updated version at line $NEXT_LINE_NUM"
  else
    echo "Warning: Line after 'group 'xyz.codeexplain'' does not contain a version declaration" >&2
    echo "Falling back to global search and replace" >&2
    # Fall back to the global search and replace
    if grep -q "version '[^']*'" "$BUILD_GRADLE"; then
      # Version is defined with single quotes
      sed -i.bak "s/version '[^']*'/version '$NEW_VERSION'/" "$BUILD_GRADLE"
    elif grep -q 'version "[^"]*"' "$BUILD_GRADLE"; then
      # Version is defined with double quotes
      sed -i.bak "s/version \"[^\"]*\"/version \"$NEW_VERSION\"/" "$BUILD_GRADLE"
    else
      echo "Error: Could not find version pattern in $BUILD_GRADLE" >&2
      exit 1
    fi
    
    # Remove backup file
    rm -f "${BUILD_GRADLE}.bak"
  fi
else
  echo "Warning: Could not find 'group 'xyz.codeexplain'' in $BUILD_GRADLE" >&2
  echo "Falling back to global search and replace" >&2
  # Fall back to the global search and replace
  if grep -q "version '[^']*'" "$BUILD_GRADLE"; then
    # Version is defined with single quotes
    sed -i.bak "s/version '[^']*'/version '$NEW_VERSION'/" "$BUILD_GRADLE"
  elif grep -q 'version "[^"]*"' "$BUILD_GRADLE"; then
    # Version is defined with double quotes
    sed -i.bak "s/version \"[^\"]*\"/version \"$NEW_VERSION\"/" "$BUILD_GRADLE"
  else
    echo "Error: Could not find version pattern in $BUILD_GRADLE" >&2
    exit 1
  fi
  
  # Remove backup file
  rm -f "${BUILD_GRADLE}.bak"
fi

echo "Updated $BUILD_GRADLE with new version: $NEW_VERSION"

# Output the new version (for use in scripts)
echo "$NEW_VERSION"
EOL

          # Make scripts executable
          chmod +x get-current-version.sh
          chmod +x bump-version.sh
          
          # Debug: Show current version
          echo "Current version information:"
          ./get-current-version.sh

      - name: Calculate next version
        id: calculate_version
        run: |
          # Determine if this is a prerelease
          SNAPSHOT_FLAG=""
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.prerelease }}" == "true" ]]; then
            SNAPSHOT_FLAG="--snapshot"
          fi
          
          # Use the bump-version script to calculate the next version (patch increment)
          NEW_VERSION=$(./bump-version.sh build.gradle patch $SNAPSHOT_FLAG)
          
          # Set the output variable for use in later steps
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version will be: $NEW_VERSION"

      - name: Build plugin
        run: ./gradlew buildPlugin

      - name: Create Git Tag
        run: |
          git tag -a v${{ steps.calculate_version.outputs.new_version }} -m "Release v${{ steps.calculate_version.outputs.new_version }}"
          git push origin v${{ steps.calculate_version.outputs.new_version }}

      - name: List Distribution Files
        run: |
          echo "Listing files in build/distributions:"
          ls -la build/distributions/

      - name: Create GitHub Release
        id: create_release
        run: |
          # Find the built plugin ZIP file
          PLUGIN_ZIP=$(find build/distributions -name "*.zip" | head -n 1)
          if [ -z "$PLUGIN_ZIP" ]; then
            echo "No ZIP file found in build/distributions. Using wildcard pattern."
            PLUGIN_ZIP="build/distributions/*.zip"
          fi
          echo "Found plugin ZIP: $PLUGIN_ZIP"

          # Create a release using GitHub CLI
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.prerelease }}" == "true" ]]; then
            gh release create v${{ steps.calculate_version.outputs.new_version }} "$PLUGIN_ZIP" \
              --title "Release v${{ steps.calculate_version.outputs.new_version }}" \
              --notes "Automated release v${{ steps.calculate_version.outputs.new_version }}" \
              --prerelease
          else
            gh release create v${{ steps.calculate_version.outputs.new_version }} "$PLUGIN_ZIP" \
              --title "Release v${{ steps.calculate_version.outputs.new_version }}" \
              --notes "Automated release v${{ steps.calculate_version.outputs.new_version }}"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Plugin to JetBrains Marketplace
        if: ${{ !(github.event_name == 'workflow_dispatch' && github.event.inputs.prerelease) }}
        run: |
          if [ -n "${{ secrets.INTELLIJ_MARKETPLACE_TOKEN }}" ]; then
            ./gradlew publishPlugin
          else
            echo "INTELLIJ_MARKETPLACE_TOKEN not set, skipping marketplace upload"
          fi
        env:
          INTELLIJ_MARKETPLACE_TOKEN: ${{ secrets.INTELLIJ_MARKETPLACE_TOKEN }}
